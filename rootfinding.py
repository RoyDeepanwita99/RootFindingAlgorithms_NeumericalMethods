# -*- coding: utf-8 -*-
"""rootfinding.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WnL6TVdB2i7Y35Dmts20yCKE9ESbUmn6
"""

import matplotlib.pyplot as plt
#Deepanwita Roy


def fp_method(func,a,b,error_accept):
    def f(x):
      f=eval(func)
      return f


    i=0
    c_before=0
    c=(a*f(b)-b*f(a))/(f(b)-f(a))
    error=abs(c-c_before)


    while error> error_accept:
      c_after=(a*f(b)-b*f(a))/(f(b)-f(a))

      if  f(a)* f(c_after)<0:
           error=abs(c_after-b)

           b=c_after
           i=i+1

      else :
           error=abs(c_after-a)

           a=c_after
           i=i+1
    print("****Using regular falsi  method, Root:", c)
    print(error, "after", i, "iteration")



def bisection(func,a,b,error_accept):
    def f(x):
      f=eval(func)
      return f


    error=abs(b-a)

    i=0
    while error> error_accept:
      c=(a+b)/2

      if  f(a)* f(c)<0:
          error=abs(b-a)
          b=c
          i=i+1

      else :
          error=abs(b-a)
          a=c
          i=i+1




    print("****Using Bysection method,Root:", c)
    print(error, "after", i, "iteration")





fp_method("4*x**3 + 3*x -3",0,1,0.05)
bisection("4*x**3 + 3*x -3",0,1,0.05)

def newtonraphson_method(func,funcderiv,x,n):
  def f(x):
    f=eval(func)
    return f

  def df(x):
    df=eval(funcderiv)
    return df

  for intercept in range(1 , n):
    c=x-(f(x)/df(x))

  print("****Using Newton Raphson method, root found ",c,"after",n,"iteration")
newtonraphson_method("4*x**3 + 3*x -3","12*x + 3",1,6)